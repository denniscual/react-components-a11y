import React, {
  createContext,
  Dispatch,
  MutableRefObject,
  RefObject,
  SetStateAction,
  useContext,
  useMemo,
  useRef,
  useState,
} from 'react'
import {
  forwardRefWithAs,
  KEYBOARD_KEYS,
  useForkedRef,
  useIsomorphicLayoutEffect,
  wrapEventHandler,
  makeId,
  makeHash,
} from '../../utils'
import createDescendantsManager, {
  DescendantType,
} from '../CustomDescendantsManager'
import Portal from '../portal'

const {
  useDescendantsState,
  DescendantsProvider,
  useRegisterDescendant,
} = createDescendantsManager('ComboboxDescendants')

enum ComboOptionTypes {
  notSelected = 'notSelected',
  selected = 'selected',
  hidden = 'hidden',
}

interface ComboOptionOtherType {
  type: ComboOptionTypes
  label: string
  isCurrent: boolean
  id: number
}

type ComboOptionType = DescendantType<ComboOptionOtherType>

// TODO: Dynamically handle the element's id.

/**
 *  A combobox is a widget made up of the combination of two distinct elements: 1) a single-line textbox, and 2) an
 *  associated pop-up element for helping users set the value of the textbox. The popup may be a listbox, grid,
 *  tree, or dialog.
 *
 *  Note that the role, state, and property guidance is based on ARIA 1.1
 *
 *  @see https://www.w3.org/TR/wai-aria-practices-1.1/#combobox
 * */
const Combobox = forwardRefWithAs<HTMLDivElement, {}, 'div'>(function Combobox({
  as: Comp = 'div',
  id = 'Combobox',
  ...otherProps
}) {
  const comboboxRef = useRef<HTMLDivElement | null>(null)
  const [isPopupOpen, setIsPopupOpen] = useState(false)

  const comboboxInputRef = useRef<HTMLInputElement | null>(null)
  const ctxValue = useMemo(
    () => ({
      isPopupOpenState: [isPopupOpen, setIsPopupOpen] as IsPopupOpenState,
      comboboxInputRef,
      id,
    }),
    [comboboxInputRef, isPopupOpen, id]
  )

  return (
    <DescendantsProvider>
      <ComboboxContext.Provider value={ctxValue}>
        <Comp
          ref={comboboxRef}
          role="combobox"
          /**
           * When the combobox popup is not visible, the element with role combobox has aria-expanded set to false.
           * When the popup element is visible, aria-expanded is set to true. Note that elements with role combobox
           * have a default value for aria-expanded of false.
           * */
          aria-expanded={isPopupOpen}
          {...otherProps}
        />
      </ComboboxContext.Provider>
    </DescendantsProvider>
  )
})

const ComboboxContext = createContext<{
  isPopupOpenState: IsPopupOpenState
  comboboxInputRef: MutableRefObject<HTMLInputElement | null>
  id: string
}>({
  id: 'Combobox',
  isPopupOpenState: [false, () => {}],
  comboboxInputRef: { current: null },
})

type IsPopupOpenState = [
  isPopupOpen: boolean,
  setIsPopupOpen: Dispatch<SetStateAction<boolean>>
]

/**
 *
 * The nature of the suggested values and the way the suggestions are presented is called the autocomplete behavior. Comboboxes
 * can have one of four forms of autocomplete:
 *
 *   1. No autocomplete
 *   2. List autocomplete with manual selection
 *   3. List autocomplete with automatic selection
 *   4. List with inline autocomplete
 * */
const ComboboxInput = forwardRefWithAs<HTMLInputElement, {}, 'input'>(
  function ComboboxInput(
    {
      as: Comp = 'input',
      value,
      onChange,
      onKeyDown,
      onFocus,
      onBlur,
      ...otherProps
    },
    forwardRef
  ) {
    const {
      isPopupOpenState: [, setIsPopupOpen],
      comboboxInputRef,
    } = useContext(ComboboxContext)

    const {
      getSelectedOption,
      makeOptionSelected,
      getPrevOption,
      getNextOption,
      getHead,
      getTail,
      handleChangeValue,
    } = useComboOptionDescendants()
    const selectedOption = getSelectedOption()
    const trimmedValue = value.trim()

    const handleChange: React.ChangeEventHandler<HTMLInputElement> = (
      event
    ) => {
      handleChangeValue(event.target.value.trim())
    }

    const handleKeyDown: React.KeyboardEventHandler<HTMLInputElement> = (
      event
    ) => {
      switch (event.key) {
        case KEYBOARD_KEYS.ARROW_DOWN: {
          setIsPopupOpen(true)
          // Alt + Down Arrow (Optional): If the popup is available but not displayed, displays the popup without moving focus.
          if (event.altKey) {
            break
          }
          // If there is selected option.
          if (selectedOption) {
            const nextOption = getNextOption(selectedOption)
            if (nextOption) {
              makeOptionSelected(nextOption.others.id)
            }
          }
          break
        }
        case KEYBOARD_KEYS.ESCAPE: {
          setIsPopupOpen(false)
          break
        }
      }
    }

    function handleFocus() {
      if (Boolean(trimmedValue)) {
        handleChangeValue(trimmedValue)
      }
    }

    function handleBlur() {
      /* setIsPopupOpen(false) */
    }

    const ref = useForkedRef(comboboxInputRef, forwardRef)

    return (
      <Comp
        ref={ref}
        value={value}
        onChange={wrapEventHandler(onChange, handleChange)}
        /**
         * It is displayed when the Down Arrow key is pressed or the show button is activated,
         * possibly with a dependency on the content of the textbox.
         * */
        onKeyDown={wrapEventHandler(onKeyDown, handleKeyDown)}
        /**
         * If the element receives focus, we shows the popup list.
         * */
        onFocus={wrapEventHandler(onFocus, handleFocus)}
        onBlur={wrapEventHandler(onBlur, handleBlur)}
        /**
         *  TODO: This aria-controls must be included on the textbox if the listbox is displayed.
         *
         * When the combobox popup is visible, the textbox element has aria-controls set to a value
         * that refers to the combobox popup element.
         * */
        aria-controls="combobox-list"
        /**
         * When a descendant of a listbox, grid, or tree popup is focused, DOM focus remains on the textbox and the
         * textbox has aria-activedescendant set to a value that refers to the focused element within the popup.
         * */
        aria-activedescendant="option-1"
        type="text"
        /**
         * Specify what kind of autocomplete does the combobox do.
         * */
        aria-autocomplete="list"
        {...otherProps}
      />
    )
  }
)

/**
 * The popup is hidden by default, and the conditions that trigger its display are specific to each implementation.
 * Some possible popup display conditions include:
 *   - It is displayed only if a certain number of characters are typed in the textbox and those characters match
 *     some portion of one of the suggested values.
 *   - It is displayed as soon as the textbox is focused, even if the textbox is empty.
 *   - It is displayed when the Down Arrow key is pressed or the show button is activated, possibly with a dependency on the content of the textbox.
 *   - It is displayed if the value of the textbox is altered in a way that creates one or more partial matches to a suggested value.
 * */
const ComboboxList = forwardRefWithAs<HTMLUListElement, {}, 'ul'>(
  function ComboboxList({ as: Comp = 'ul', ...otherProps }, forwardRef) {
    const {
      isPopupOpenState: [isPopupOpen],
      comboboxInputRef,
    } = useContext(ComboboxContext)
    return (
      <Popover targetRef={comboboxInputRef}>
        {isPopupOpen && (
          <Comp
            ref={forwardRef}
            id="combobox-list"
            /**
             * An element that contains or owns all the listbox options has role listbox.
             * */
            role="listbox"
            /**
             * Each option in the listbox has role option and is a DOM descendant of the element with role listbox
             * or is referenced by an aria-owns property on the listbox element.
             * */
            aria-owns=""
            aria-hidden={true}
            {...otherProps}
          ></Comp>
        )}
      </Popover>
    )
  }
)

const ComboboxOption = forwardRefWithAs<
  HTMLLIElement,
  { label: string },
  'li',
  { children: React.ReactNode }
>(function ComboboxOption(
  { as: Comp = 'li', label, ...otherProps },
  forwardRef
) {
  const ownRef = useRef<HTMLLIElement | null>(null)
  const { id } = useContext(ComboboxContext)
  const { makeOptionSelected } = useComboOptionDescendants()
  const ownDescendantWithIndex = useRegisterDescendant({
    element: ownRef.current,
    // The initial combo option type is `notSelected`.
    others: {
      type: ComboOptionTypes.notSelected,
      label,
      isCurrent: false,
      id: makeHash(label),
    },
  })
  const isSelected =
    ownDescendantWithIndex &&
    ownDescendantWithIndex.descendant.others.type === ComboOptionTypes.selected
  const isHidden =
    ownDescendantWithIndex &&
    ownDescendantWithIndex.descendant.others.type === ComboOptionTypes.hidden
  const ref = useForkedRef(ownRef, forwardRef)
  const optionId = ownDescendantWithIndex?.descendant.others.id ?? 0
  const optionElId = makeId(id, ownDescendantWithIndex?.index ?? -1)

  function handleClick() {
    if (ownDescendantWithIndex && !isSelected) {
      makeOptionSelected(optionId)
    }
  }

  return (
    <Comp
      hidden={isHidden}
      id={optionElId}
      ref={ref}
      onClick={handleClick}
      /**
       * Each option in the listbox has role option and is a DOM descendant of the element with role listbox
       * */
      role="option"
      aria-selected={isSelected}
      style={{
        color: isSelected ? 'lightblue' : 'black',
      }}
      {...otherProps}
    >
      {label}
    </Comp>
  )
})

function useComboOptionDescendants() {
  const [comboOptions, setComboOptions] = useDescendantsState<
    ComboOptionOtherType
  >()

  return useMemo(() => {
    function getSelectedOption() {
      return comboOptions.find(
        (descendant) => descendant.others.type === ComboOptionTypes.selected
      )
    }

    function getPrevOption(currentOption: ComboOptionType) {
      const index = comboOptions.findIndex(
        (descendant) => descendant.others.id === currentOption.others.id
      )
      if (index === 0) {
        return null
      }
      const foundOption = comboOptions[index - 1]
      return nullableData(foundOption)
    }

    function getNextOption(currentOption: ComboOptionType) {
      const index = comboOptions.findIndex(
        (descendant) => descendant.others.id === currentOption.others.id
      )
      if (index === comboOptions.length - 1) {
        return null
      }
      const foundOption = comboOptions[index + 1]
      return nullableData(foundOption)
    }

    function makeOptionSelected(optionId: number) {
      setComboOptions((prevOptions) => {
        return prevOptions.map((prevOption) => {
          if (prevOption.others.id === optionId) {
            return {
              ...prevOption,
              others: {
                ...prevOption.others,
                type: ComboOptionTypes.selected,
              },
            }
          }
          return {
            ...prevOption,
            others: {
              ...prevOption.others,
              // Make the prev option selected to not selected without affecting the hidden option.
              type:
                prevOption.others.type === ComboOptionTypes.selected
                  ? ComboOptionTypes.notSelected
                  : prevOption.others.type,
            },
          }
        })
      })
    }

    function getHead() {
      const head = comboOptions[0]
      return nullableData(head)
    }

    function getTail() {
      const tail = comboOptions[comboOptions.length - 1]
      return nullableData(tail)
    }

    function handleChangeValue(value: string) {
      const newComboOptions = []
      let firstSelectedOption = null
      for (const option of comboOptions) {
        if (!option.others.label.includes(value)) {
          newComboOptions.push({
            ...option,
            others: {
              ...option.others,
              type: ComboOptionTypes.hidden,
            },
          })
        } else {
          let newOption = {
            ...option,
            others: {
              ...option.others,
              type: ComboOptionTypes.notSelected,
            },
          }
          if (!firstSelectedOption && value !== '') {
            newOption = {
              ...option,
              others: {
                ...option.others,
                type: ComboOptionTypes.selected,
              },
            }
            firstSelectedOption = newOption
          }
          newComboOptions.push(newOption)
        }
      }
      setComboOptions(newComboOptions)
    }

    return {
      getSelectedOption,
      getPrevOption,
      getNextOption,
      makeOptionSelected,
      getHead,
      getTail,
      handleChangeValue,
    }
  }, [setComboOptions, comboOptions])
}

const Popover = forwardRefWithAs<
  HTMLDivElement,
  {
    targetRef: RefObject<HTMLElement>
  },
  'div'
>(function Popover(
  { as: Comp = 'div', domRect, targetRef, ...otherProps },
  forwardRef
) {
  const [ownPosition, setOwnPosition] = useState(() => new DOMRect())
  const ownRef = useRef<HTMLDivElement | null>(null)
  const ref = useForkedRef(forwardRef, ownRef)

  useIsomorphicLayoutEffect(() => {
    if (targetRef.current) {
      setOwnPosition(targetRef.current.getBoundingClientRect())
    }
  }, [targetRef])

  return (
    <Portal>
      <Comp
        id="popover"
        ref={ref}
        style={{
          position: 'absolute',
          left: ownPosition.left,
          top: ownPosition.bottom,
        }}
        {...otherProps}
      />
    </Portal>
  )
})

function nullableData<T>(data: T) {
  return data ? data : null
}

export { Combobox, ComboboxInput, ComboboxList, ComboboxOption }
